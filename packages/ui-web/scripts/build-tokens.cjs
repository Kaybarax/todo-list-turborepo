const StyleDictionary = require('style-dictionary').default;

// Custom transforms for DaisyUI compatibility
StyleDictionary.registerTransform({
  name: 'size/px',
  type: 'value',
  filter: token => token.attributes?.category === 'size' || token.attributes?.category === 'space',
  transform: token => {
    try {
      if (typeof token.original.value === 'string' && token.original.value.includes('rem')) {
        return token.original.value;
      }
      return parseFloat(token.original.value) + 'px';
    } catch (error) {
      console.error(`Error transforming token ${token.name}:`, error);
      return token.original.value;
    }
  },
});

StyleDictionary.registerTransform({
  name: 'color/hex',
  type: 'value',
  filter: token => token.attributes?.category === 'color',
  transform: token => token.original.value,
});

// Custom filter for Tailwind-compatible tokens
StyleDictionary.registerFilter({
  name: 'tailwind-compatible',
  filter: token => {
    return ['color', 'size', 'space', 'fontFamily', 'fontSize', 'borderRadius', 'boxShadow', 'fontWeight'].includes(token.attributes?.category);
  },
});

// Custom format for TypeScript declarations
StyleDictionary.registerFormat({
  name: 'typescript/es6-declarations',
  format: function(dictionary) {
    const tokens = dictionary.allTokens;
    
    // Group tokens by category
    const tokensByCategory = tokens.reduce((acc, token) => {
      const category = token.attributes.category;
      if (!acc[category]) acc[category] = {};
      
      // Handle nested tokens (e.g., primary.500)
      const path = token.path.slice(1); // Remove category from path
      let current = acc[category];
      
      for (let i = 0; i < path.length - 1; i++) {
        if (!current[path[i]]) current[path[i]] = {};
        current = current[path[i]];
      }
      
      current[path[path.length - 1]] = token.value;
      return acc;
    }, {});

    let output = '// Generated by Style Dictionary\n\n';
    
    // Generate interfaces for each category
    Object.keys(tokensByCategory).forEach(category => {
      const categoryName = category.charAt(0).toUpperCase() + category.slice(1);
      output += `export interface ${categoryName}Tokens {\n`;
      output += generateInterface(tokensByCategory[category], 2);
      output += '}\n\n';
    });

    // Generate main DesignTokens interface
    output += 'export interface DesignTokens {\n';
    Object.keys(tokensByCategory).forEach(category => {
      const categoryName = category.charAt(0).toUpperCase() + category.slice(1);
      output += `  ${category}: ${categoryName}Tokens;\n`;
    });
    output += '}\n\n';

    // Generate DaisyUI types
    output += `export type DaisyUISize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';\n`;
    output += `export type DaisyUIColor = 'primary' | 'secondary' | 'accent' | 'neutral' | 'info' | 'success' | 'warning' | 'error';\n`;
    output += `export type DaisyUITheme = 'light' | 'dark' | 'cupcake' | 'bumblebee' | 'emerald' | 'corporate' | 'synthwave' | 'retro' | 'cyberpunk' | 'valentine' | 'halloween' | 'garden' | 'forest' | 'aqua' | 'lofi' | 'pastel' | 'fantasy' | 'wireframe' | 'black' | 'luxury' | 'dracula' | 'cmyk' | 'autumn' | 'business' | 'acid' | 'lemonade' | 'night' | 'coffee' | 'winter' | 'dim' | 'nord' | 'sunset' | 'todo-light' | 'todo-dark';\n\n`;

    // Generate component prop interfaces
    output += `export interface DaisyUIComponentProps {\n`;
    output += `  size?: DaisyUISize;\n`;
    output += `  color?: DaisyUIColor;\n`;
    output += `  disabled?: boolean;\n`;
    output += `  loading?: boolean;\n`;
    output += `}\n\n`;

    output += `export interface ButtonProps extends DaisyUIComponentProps {\n`;
    output += `  outline?: boolean;\n`;
    output += `  ghost?: boolean;\n`;
    output += `  link?: boolean;\n`;
    output += `  block?: boolean;\n`;
    output += `  wide?: boolean;\n`;
    output += `  square?: boolean;\n`;
    output += `  circle?: boolean;\n`;
    output += `}\n\n`;

    output += `export interface InputProps extends DaisyUIComponentProps {\n`;
    output += `  bordered?: boolean;\n`;
    output += `  ghost?: boolean;\n`;
    output += `  error?: boolean;\n`;
    output += `}\n`;

    return output;
  }
});

// Custom format for Tailwind tokens that ensures module export
StyleDictionary.registerFormat({
  name: 'javascript/tailwind-module',
  format: function (dictionary) {
    // Build a plain nested object from tokens: { [category]: { ...paths }: value }
    const result = {};
    for (const token of dictionary.allTokens) {
      const category = token.attributes?.category || token.path[0];
      if (!result[category]) result[category] = {};

      // Build nested structure for remaining path segments
      const path = token.path.slice(1);
      let cursor = result[category];
      for (let i = 0; i < path.length - 1; i++) {
        const key = path[i];
        if (!cursor[key]) cursor[key] = {};
        cursor = cursor[key];
      }
      const leaf = path[path.length - 1];
      cursor[leaf] = token.value;
    }

    return `// Generated Tailwind-compatible tokens\nmodule.exports = ${JSON.stringify(result, null, 2)};`;
  },
});

// Custom format for DaisyUI theme configuration as JavaScript module
StyleDictionary.registerFormat({
  name: 'javascript/daisyui-themes',
  format: function (dictionary) {
    const tokens = dictionary.allTokens;

    // Filter semantic color tokens
    const semanticTokens = tokens.filter(
      token => token.path[0] === 'semantic' && token.path[1] === 'color'
    );

    // Build theme -> { key: value } map first
    const themes = {};
    semanticTokens.forEach(token => {
      const theme = `todo-${token.path[2]}`; // light | dark => todo-light | todo-dark
      const key = token.path.slice(3).join('-');
      if (!themes[theme]) themes[theme] = {};
      themes[theme][key] = token.value;
    });

    // Map semantic keys to DaisyUI CSS variable names
    const mapKeyToCssVar = key => {
      const map = {
        'primary': '--p',
        'primary-content': '--pc',
        'secondary': '--s',
        'secondary-content': '--sc',
        'accent': '--a',
        'accent-content': '--ac',
        'neutral': '--n',
        'neutral-content': '--nc',
        'base-100': '--b1',
        'base-200': '--b2',
        'base-300': '--b3',
        'base-content': '--bc',
        'info': '--in',
        'info-content': '--inc',
        'success': '--su',
        'success-content': '--suc',
        'warning': '--wa',
        'warning-content': '--wac',
        'error': '--er',
        'error-content': '--erc',
      };
      return map[key] || null; // ignore -focus keys for CSS variables
    };

    // Generate CSS-style theme selectors with variables
    let cssOutput = '// Generated DaisyUI theme configuration\n';
    cssOutput += 'const themes = `\n';
    
    Object.entries(themes).forEach(([themeName, values]) => {
      cssOutput += `[data-theme="${themeName}"] {\n`;
      Object.entries(values).forEach(([k, v]) => {
        const cssVar = mapKeyToCssVar(k);
        if (cssVar) {
          cssOutput += `  ${cssVar}: ${v};\n`;
        }
      });
      cssOutput += '}\n\n';
    });
    
    cssOutput += '`;\n\n';
    
    // Also export as JavaScript object for programmatic access
    const daisyuiThemes = {};
    Object.entries(themes).forEach(([themeName, values]) => {
      const themeObj = {};
      Object.entries(values).forEach(([k, v]) => {
        const cssVar = mapKeyToCssVar(k);
        if (cssVar) {
          const themeKey = cssVar.replace('--', '');
          themeObj[themeKey] = v;
        }
      });
      daisyuiThemes[themeName] = themeObj;
    });

    cssOutput += `const themeObjects = ${JSON.stringify(daisyuiThemes, null, 2)};\n\n`;
    cssOutput += 'module.exports = { themes, themeObjects };';

    return cssOutput;
  },
});

function generateInterface(obj, indent = 0) {
  let output = '';
  const spaces = ' '.repeat(indent);
  
  Object.keys(obj).forEach(key => {
    if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
      output += `${spaces}${key}: {\n`;
      output += generateInterface(obj[key], indent + 2);
      output += `${spaces}};\n`;
    } else {
      output += `${spaces}${key}: string;\n`;
    }
  });
  
  return output;
}

// Build configuration
const config = {
  source: ['tokens/**/*.json'],
  platforms: {
    css: {
      transformGroup: 'css',
      buildPath: 'dist/tokens/',
      files: [
        {
          destination: 'variables.css',
          format: 'css/variables',
          options: {
            outputReferences: true,
          },
        },
      ],
    },
    js: {
      transformGroup: 'js',
      buildPath: 'dist/tokens/',
      files: [
        {
          destination: 'tokens.js',
          format: 'javascript/es6',
        },
        {
          destination: 'tokens.d.ts',
          format: 'typescript/es6-declarations',
        },
      ],
    },
    tailwind: {
      transformGroup: 'js',
      buildPath: 'dist/tokens/',
      files: [
        {
          destination: 'tailwind-tokens.js',
          format: 'javascript/tailwind-module',
          filter: 'tailwind-compatible',
        },
      ],
    },
    daisyui: {
      transformGroup: 'js',
      buildPath: 'dist/tokens/',
      files: [
        {
          destination: 'daisyui-themes.js',
          format: 'javascript/daisyui-themes',
        },
      ],
    },
  },
};

// Build the tokens
async function buildTokens() {
  try {
    const sd = new StyleDictionary(config);
    await sd.buildAllPlatforms();
    console.log('✅ Style Dictionary build completed successfully');
  } catch (error) {
    console.error('❌ Style Dictionary build failed:', error.message);
    process.exit(1);
  }
}

buildTokens();
