/*
  Build UI-Mobile design tokens using Style Dictionary.
  - Registers a custom format 'typescript/es6-declarations' used by style-dictionary.config.json
  - Supports optional --watch flag to rebuild on token changes
*/

const path = require('path');
const fs = require('fs');
const { setTimeout: delay } = require('timers/promises');

let StyleDictionary;
try {
  // Style Dictionary v5 exposes default export under .default for CJS require from ESM build
  StyleDictionary = require('style-dictionary').default || require('style-dictionary');
} catch (e) {
  console.error('style-dictionary is not installed. Please install it as a devDependency.');
  process.exit(1);
}

// Register the custom TypeScript declarations format used by the config
StyleDictionary.registerFormat({
  name: 'typescript/es6-declarations',
  format: function (dictionary) {
    const tokens = dictionary.allTokens;

    const tokensByCategory = tokens.reduce((acc, token) => {
      const category = token.attributes && token.attributes.category ? token.attributes.category : token.path[0];
      if (!acc[category]) acc[category] = {};

      const pathParts = token.path.slice(1);
      let current = acc[category];
      for (let i = 0; i < pathParts.length - 1; i++) {
        if (!current[pathParts[i]]) current[pathParts[i]] = {};
        current = current[pathParts[i]];
      }
      current[pathParts[pathParts.length - 1]] = token.value;
      return acc;
    }, {});

    const generateInterface = (obj, indent = 2) => {
      const pad = ' '.repeat(indent);
      let out = '';
      for (const key of Object.keys(obj)) {
        const val = obj[key];
        if (val && typeof val === 'object') {
          out += `${pad}${key}: {\n`;
          out += generateInterface(val, indent + 2);
          out += `${pad}};\n`;
        } else {
          out += `${pad}${key}: string;\n`;
        }
      }
      return out;
    };

    let output = '// Generated by Style Dictionary for ui-mobile\n\n';
    Object.keys(tokensByCategory).forEach(category => {
      const categoryName = category.charAt(0).toUpperCase() + category.slice(1);
      output += `export interface ${categoryName}Tokens {\n`;
      output += generateInterface(tokensByCategory[category], 2);
      output += '}\n\n';
    });

    output += 'export interface DesignTokens {\n';
    Object.keys(tokensByCategory).forEach(category => {
      const categoryName = category.charAt(0).toUpperCase() + category.slice(1);
      output += `  ${category}: ${categoryName}Tokens;\n`;
    });
    output += '}\n';

    return output;
  },
});

const rootDir = path.resolve(__dirname, '..');
const configPath = path.resolve(rootDir, 'style-dictionary.config.json');

async function buildOnce() {
  console.log('[ui-mobile][tokens] Building design tokens...');
  const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
  const sd = new StyleDictionary(config);
  await sd.buildAllPlatforms();
  console.log('[ui-mobile][tokens] Build complete.');
}

async function watch() {
  console.log('[ui-mobile][tokens] Watching tokens for changes...');
  const watchDirs = [
    path.resolve(rootDir, 'tokens'),
    configPath,
  ];

  let pending = false;
  const trigger = async () => {
    if (pending) return;
    pending = true;
    try {
      buildOnce();
    } catch (e) {
      console.error('[ui-mobile][tokens] Build error:', e);
    } finally {
      await delay(100);
      pending = false;
    }
  };

  // Initial build
  trigger();

  watchDirs.forEach(target => {
    if (!fs.existsSync(target)) return;
    const isDir = fs.existsSync(target) && fs.statSync(target).isDirectory();
    const watcher = fs.watch(target, { recursive: isDir }, () => {
      trigger();
    });
    watcher.on('error', err => console.error('[ui-mobile][tokens] Watcher error:', err));
  });
}

if (process.argv.includes('--watch')) {
  watch();
} else {
  buildOnce();
}
